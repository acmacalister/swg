package swg

import (
	"fmt"
	"io"
	"net/http"
	"os"
	"strings"
	"text/template"
)

// PACGenerator generates Proxy Auto-Configuration (PAC) files.
type PACGenerator struct {
	// ProxyAddr is the proxy address in host:port format (e.g., "proxy.local:8080").
	ProxyAddr string

	// BypassDomains are domains that should bypass the proxy (direct connection).
	BypassDomains []string

	// BypassNetworks are CIDR networks that should bypass the proxy.
	BypassNetworks []string

	// FallbackDirect determines whether to fall back to direct connection
	// if the proxy is unreachable.
	FallbackDirect bool
}

// NewPACGenerator creates a PACGenerator for the given proxy address.
func NewPACGenerator(proxyAddr string) *PACGenerator {
	return &PACGenerator{
		ProxyAddr: proxyAddr,
		BypassDomains: []string{
			"localhost",
			"127.0.0.1",
			"::1",
		},
		BypassNetworks: []string{
			"10.0.0.0/8",
			"172.16.0.0/12",
			"192.168.0.0/16",
			"169.254.0.0/16",
		},
		FallbackDirect: true,
	}
}

// AddBypassDomain adds a domain to the bypass list.
// Supports wildcards: ".example.com" bypasses all subdomains.
func (g *PACGenerator) AddBypassDomain(domain string) {
	g.BypassDomains = append(g.BypassDomains, domain)
}

// AddBypassNetwork adds a CIDR network to the bypass list.
func (g *PACGenerator) AddBypassNetwork(cidr string) {
	g.BypassNetworks = append(g.BypassNetworks, cidr)
}

// pacData is the template data for PAC file generation.
type pacData struct {
	ProxyAddr      string
	BypassDomains  []string
	BypassNetworks []pacNetwork
	FallbackDirect bool
	ProxyResult    string
}

type pacNetwork struct {
	Address string
	Mask    string
}

var pacTemplate = template.Must(template.New("pac").Parse(pacTemplateStr))

const pacTemplateStr = `// PAC file generated by SWG - Secure Web Gateway
// Proxy: {{.ProxyAddr}}

function FindProxyForURL(url, host) {
    // Strip port from host
    if (host.indexOf(":") !== -1) {
        host = host.split(":")[0];
    }
    host = host.toLowerCase();

    // Bypass proxy for localhost and local addresses
    if (isPlainHostName(host)) {
        return "DIRECT";
    }
{{range .BypassDomains}}
    if (dnsDomainIs(host, "{{.}}") || host === "{{.}}") {
        return "DIRECT";
    }
{{end}}{{range .BypassNetworks}}
    if (isInNet(host, "{{.Address}}", "{{.Mask}}")) {
        return "DIRECT";
    }
{{end}}
    return "{{.ProxyResult}}";
}
`

// Generate writes the PAC file content to the given writer.
func (g *PACGenerator) Generate(w io.Writer) error {
	data := pacData{
		ProxyAddr:      g.ProxyAddr,
		BypassDomains:  g.BypassDomains,
		BypassNetworks: g.parseNetworks(),
		FallbackDirect: g.FallbackDirect,
	}

	if g.FallbackDirect {
		data.ProxyResult = fmt.Sprintf("PROXY %s; DIRECT", g.ProxyAddr)
	} else {
		data.ProxyResult = fmt.Sprintf("PROXY %s", g.ProxyAddr)
	}

	return pacTemplate.Execute(w, data)
}

// GenerateString returns the PAC file content as a string.
func (g *PACGenerator) GenerateString() (string, error) {
	var sb strings.Builder
	if err := g.Generate(&sb); err != nil {
		return "", err
	}
	return sb.String(), nil
}

// WriteFile writes the PAC file to the given path.
func (g *PACGenerator) WriteFile(path string) error {
	f, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("create PAC file: %w", err)
	}
	defer func() { _ = f.Close() }()

	if err := g.Generate(f); err != nil {
		return fmt.Errorf("generate PAC file: %w", err)
	}

	return nil
}

// ServeHTTP implements http.Handler, serving the PAC file with the correct content type.
func (g *PACGenerator) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/x-ns-proxy-autoconfig")
	w.Header().Set("Cache-Control", "max-age=300")
	_ = g.Generate(w)
}

// parseNetworks converts CIDR notation to address/mask pairs for PAC isInNet().
func (g *PACGenerator) parseNetworks() []pacNetwork {
	var networks []pacNetwork
	for _, cidr := range g.BypassNetworks {
		parts := strings.SplitN(cidr, "/", 2)
		if len(parts) != 2 {
			continue
		}
		mask := cidrToMask(parts[1])
		if mask != "" {
			networks = append(networks, pacNetwork{
				Address: parts[0],
				Mask:    mask,
			})
		}
	}
	return networks
}

// cidrToMask converts a CIDR prefix length to a dotted subnet mask.
func cidrToMask(prefix string) string {
	masks := map[string]string{
		"8":  "255.0.0.0",
		"12": "255.240.0.0",
		"16": "255.255.0.0",
		"20": "255.255.240.0",
		"24": "255.255.255.0",
		"28": "255.255.255.240",
		"32": "255.255.255.255",
	}

	if m, ok := masks[prefix]; ok {
		return m
	}

	var bits int
	if _, err := fmt.Sscanf(prefix, "%d", &bits); err != nil || bits < 0 || bits > 32 {
		return ""
	}

	var mask [4]byte
	for i := 0; i < 4; i++ {
		if bits >= 8 {
			mask[i] = 255
			bits -= 8
		} else {
			mask[i] = byte(0xFF << (8 - bits))
			bits = 0
		}
	}
	return fmt.Sprintf("%d.%d.%d.%d", mask[0], mask[1], mask[2], mask[3])
}
